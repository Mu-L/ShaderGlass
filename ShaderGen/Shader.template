/*
%HEADER%
*/

#pragma once

namespace %LIB_NAME%%CLASS_NAME%ShaderDefs
{
static const BYTE sVertexByteCode[] =
%VERTEX_BYTECODE%

static const BYTE sFragmentByteCode[] =
%FRAGMENT_BYTECODE%

static const uint32_t sVertexHash[] = 
%VERTEX_HASH%

static const uint32_t sFragmentHash[] =
%FRAGMENT_HASH%

static constexpr ShaderParamDef sParamDefs[] = {
%PARAM%		ShaderParamDef { .name = "%PARAM_NAME%", .buffer = %PARAM_BUFFER%, .offset = %PARAM_OFFSET%, .size = %PARAM_SIZE%, .minValue = %PARAM_MIN%f, .maxValue = %PARAM_MAX%f, .defaultValue = %PARAM_DEF%f, .stepValue = %PARAM_STEP%f, .description = "%PARAM_DESC%" },
};
}

namespace %LIB_NAME%
{
class %CLASS_NAME%ShaderDef : public ShaderDef
{
public:
	%CLASS_NAME%ShaderDef() : ShaderDef{}
	{
		Name = "%SHADER_NAME%";
		VertexByteCode = %LIB_NAME%%CLASS_NAME%ShaderDefs::sVertexByteCode;
		VertexLength = sizeof(%LIB_NAME%%CLASS_NAME%ShaderDefs::sVertexByteCode);
		VertexHash = %LIB_NAME%%CLASS_NAME%ShaderDefs::sVertexHash;
		FragmentByteCode = %LIB_NAME%%CLASS_NAME%ShaderDefs::sFragmentByteCode;
		FragmentLength = sizeof(%LIB_NAME%%CLASS_NAME%ShaderDefs::sFragmentByteCode);
		FragmentHash = %LIB_NAME%%CLASS_NAME%ShaderDefs::sFragmentHash;
		Format = "%SHADER_FORMAT%";
		AddParams(%LIB_NAME%%CLASS_NAME%ShaderDefs::sParamDefs, sizeof(%LIB_NAME%%CLASS_NAME%ShaderDefs::sParamDefs) / sizeof(ShaderParamDef));
%TEXTURE%		AddSampler("%TEXTURE_NAME%", %TEXTURE_BINDING%);
/*
VertexSource = %*VERTEX_SOURCE*%;
*/
/*
FragmentSource = %*FRAGMENT_SOURCE*%;
*/
	}
};
}